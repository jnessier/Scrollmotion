/*!
* Scrollmotion v0.4.0
* Copyright 2022 Jonathan Nessier, Neoflow
* Licensed under MIT
*/
var Scrollmotion=function(){"use strict";class t{constructor(t,i){this.mutationObserver=null,this.selector=t,this.options=i,this.container=document,this.options.root&&this.options.root.nodeType===Node.ELEMENT_NODE?this.container=this.options.root:this.options.root=null,this.items=Array.from(this.container.querySelectorAll(this.selector)),this.items.forEach((t=>{this.options.prepareItem(t)})),this.intersectionObserver=this.createIntersectionObserver(),this.options.observeMutation&&(this.mutationObserver=this.createMutationObserver()),"function"==typeof this.options.initialized&&this.options.initialized(this.container,this.items)}createIntersectionObserver(){const t=new IntersectionObserver((i=>{i.forEach((i=>{const e=i.target;let s=this.options.ratio;e.dataset.smRatio&&(s=e.dataset.smRatio),i.isIntersecting&&i.intersectionRatio>=s&&(this.animate(e),t.unobserve(e))}))}),{root:this.options.root,rootMargin:this.options.rootMargin,threshold:this.options.threshold});return t}createMutationObserver(){return new MutationObserver((t=>{t.forEach((t=>{null!==t.addedNodes&&t.addedNodes.forEach((t=>{if(t.nodeType===Node.ELEMENT_NODE){const i=t;i.matches(this.selector)&&(this.options.prepareItem(i),this.intersectionObserver.observe(i))}}))}))}))}animate(t){this.options.animateItem(t),"function"==typeof this.options.itemAnimated&&this.options.itemAnimated(t)}start(){this.items.forEach((t=>{var i;this.intersectionObserver.observe(t),null===(i=this.mutationObserver)||void 0===i||i.observe(this.container,{childList:!0,subtree:!0})})),"function"==typeof this.options.started&&this.options.started()}stop(){this.intersectionObserver.disconnect(),"function"==typeof this.options.stopped&&this.options.stopped()}}const i={root:null,rootMargin:"0px 0px 0px 0px",threshold:[0,.25,.5,.75,1],ratio:0,observeMutation:!1,initialized:null,started:null,itemAnimated:null,stopped:null,animateClass:"animate__swing",prepareItem:t=>{t.style.visibility="hidden"},animateItem:t=>{t.style.visibility="visible",t.classList.add("animate__animated"),t.dataset.smAnimateClass?t.classList.add(t.dataset.smAnimateClass):t.classList.add(i.animateClass)}};return(e=".sm-item",s)=>{const o=Object.assign({},i,s);return new t(e,o)}}();
//# sourceMappingURL=scrollmotion.min.js.map
